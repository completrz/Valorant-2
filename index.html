<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Valorant 2.0 3D Prototype - Fixed</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; color: #eee; font-family: Arial, sans-serif; }
  #info {
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    color: #eee; font-weight: bold; font-size: 18px; user-select:none;
    z-index: 10;
  }
  #instructions {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #eee; font-size: 24px; user-select:none;
    background: rgba(0,0,0,0.7); padding: 20px; border-radius: 8px;
    cursor: pointer;
    max-width: 300px;
    text-align: center;
  }
</style>
</head>
<body>
<div id="info">
  Health: <span id="health">100</span> | Dash Cooldown: <span id="dashCooldown">Ready</span>
</div>
<div id="instructions">
  Click to play<br>(WASD to move, Mouse to look, Left Click to shoot, E to dash)
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // light blue sky color

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 20, 10);
  scene.add(light);

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(100, 100);
  const floorMat = new THREE.MeshPhongMaterial({color: 0x228B22}); // forest green
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = - Math.PI / 2;
  floor.position.y = 0;
  floor.receiveShadow = true;
  scene.add(floor);

  // Player Setup
  const player = {
    height: 1.8,
    speed: 5,  // units per second
    dashSpeed: 20,
    dashCooldown: 0,
    dashDuration: 0.3,
    isDashing: false,
    dashTimeLeft: 0,
    health: 100,
    velocity: new THREE.Vector3(),
  };

  // Start camera at player's height
  camera.position.set(0, player.height, 0);

  // Pointer Lock Controls
  const controls = new THREE.PointerLockControls(camera, document.body);

  const instructions = document.getElementById('instructions');
  instructions.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    instructions.style.display = 'none';
  });
  controls.addEventListener('unlock', () => {
    instructions.style.display = 'block';
  });

  scene.add(controls.getObject());

  // Movement input
  const keys = {};
  window.addEventListener('keydown', (e) => { keys[e.code] = true; });
  window.addEventListener('keyup', (e) => { keys[e.code] = false; });

  // Enemy cube
  const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
  const enemyMaterial = new THREE.MeshPhongMaterial({color: 0xff4444});
  const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
  enemy.position.set(0, 0.5, -10);
  scene.add(enemy);
  enemy.health = 50;

  // UI elements
  const healthText = document.getElementById('health');
  const dashCooldownText = document.getElementById('dashCooldown');

  // Shooting variables
  const raycaster = new THREE.Raycaster();
  const shootCooldown = 0.3;
  let shootTimer = 0;

  // Dash variables
  const dashCooldownTime = 3;

  // Clock for delta time
  const clock = new THREE.Clock();

  function update(dt) {
    // Update dash cooldown
    if (player.dashCooldown > 0) player.dashCooldown -= dt;
    if (player.dashCooldown < 0) player.dashCooldown = 0;

    // Dash logic
    if (keys['KeyE'] && player.dashCooldown === 0 && !player.isDashing) {
      player.isDashing = true;
      player.dashTimeLeft = player.dashDuration;
      player.dashCooldown = dashCooldownTime;
    }

    if (player.isDashing) {
      player.dashTimeLeft -= dt;
      if (player.dashTimeLeft <= 0) {
        player.isDashing = false;
      }
    }

    // Movement
    if (controls.isLocked === true) {
      player.velocity.set(0, 0, 0);

      if (!player.isDashing) {
        if (keys['KeyW']) player.velocity.z -= player.speed * dt;
        if (keys['KeyS']) player.velocity.z += player.speed * dt;
        if (keys['KeyA']) player.velocity.x -= player.speed * dt;
        if (keys['KeyD']) player.velocity.x += player.speed * dt;
      } else {
        // Dash moves player forward fast
        player.velocity.z -= player.dashSpeed * dt;
      }

      // Move player relative to camera direction (XZ plane)
      const direction = new THREE.Vector3();
      controls.getDirection(direction);

      // Extract forward and right vectors on XZ plane
      const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize();
      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

      // Calculate movement
      const move = new THREE.Vector3();
      move.addScaledVector(forward, player.velocity.z);
      move.addScaledVector(right, player.velocity.x);

      controls.getObject().position.add(move);

      // Keep player above floor
      controls.getObject().position.y = player.height;
    }

    // Shoot cooldown timer
    if (shootTimer > 0) shootTimer -= dt;

    // Update UI
    healthText.textContent = player.health;
    dashCooldownText.textContent = player.dashCooldown > 0 ? player.dashCooldown.toFixed(1) + 's' : 'Ready';
  }

  function shoot() {
    if (shootTimer > 0) return; // cooldown active
    shootTimer = shootCooldown;

    // Raycast from camera center forward
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

    const intersects = raycaster.intersectObject(enemy);
    if (intersects.length > 0) {
      enemy.health -= 10;
      enemy.material.color.setHex(0xff0000);
      setTimeout(() => enemy.material.color.setHex(0xff4444), 100);
      if (enemy.health <= 0) {
        alert('Enemy defeated! You win!');
        resetGame();
      }
    }
  }

  function resetGame() {
    enemy.health = 50;
    enemy.position.set(0, 0.5, -10);
    player.health = 100;
    player.dashCooldown = 0;
    player.isDashing = false;
    controls.getObject().position.set(0, player.height, 0);
  }

  window.addEventListener('click', () => {
    if (controls.isLocked) shoot();
  });

  function animate() {
    const dt = clock.getDelta();
    update(dt);
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  resetGame();
  animate();

})();
</script>
</body>
</html>
